/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ignitron

import com.github.javaparser.Position
import com.github.javaparser.ast.Node
import com.github.javaparser.ast.body.MethodDeclaration
import com.github.javaparser.ast.stmt.BlockStmt
import com.github.javaparser.ast.stmt.Statement
import kotlin.streams.toList
import kotlinx.cli.*
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import org.eclipse.jgit.api.Git
import penta.*
import java.util.stream.Collectors
import java.util.stream.Stream

class FileCompareResult(val fst: MethodBlock, val snd: MethodBlock, val result: ComparisonResult)

typealias Original = Node
typealias Generalized = Node

class NodeSequence(val origin: Pair<Original, Original>, val modified: Pair<Original, Original>)

/*
    GENERAL APPROACH
    To best find clones and reuses in both versions of the source code we limit the amount of comparisons we'll have to make.
    One way to reduce them is to limit the used files by directly checking only changed files in the difference between the base and PR branch.
    > To further reduce them we could look up the methods that actually changed, but for now this is not done, as it requires some additionally work put in to make the detection for that work. Git diffs are not sufficient here.
    After that we can read in the trees of the new changes aswell as the files of the old base.
    - This concludes the scanning -
    After this we can compare which methods have not changed at all with a simple top down comparison. Requirements for this are:
    1. They existed before
    2. They have the same identifier
    3. They reside in the same file
    This then leaves us with the set of methods which have been changed in the PR.
    - This concludes the pre-filtering -
    Following, we'll need to pre-process trees to find potential clones in the committed source code, we may use different Transformers here to generalize the source trees. They are defined in penta and can be combined freely.
    Now we need to find the trees which have similar subtrees or are similar in it's entrirety to other subtrees, for this we can begin by hashing the present processed trees.
    This is a deep hashing by which we can find all nodes with similar-ish subtrees. They are not guaranteed to be in order or any detailed similarity.
    This leads to the more in-depth comparison.
    - This concludes the pre-matching -
    For a detailed and reliable comparison there are now some comparison methods to choose from. In the Moment we have TopDown and BottomUp, choose the best in the situation and continue to note the results of this comparison.
    The Matching is more of a sketch now, if we need to include some more steps we'll add them in development.
    - This concludes the matching -
    After that we have a pool of results and methods which share some commonalities. We can find a group of methods sharing a sub tree for example and may extract them to reduce the amount of boiler plate code etc. 
    TODO: Create an case example for that.
    The extraction consists of two parts, first we need to extract it to a place where we can reference them all, second wrap it in a method and add it to a class, third replace the position of the old subtree with a method call on the new extracted method.
    Other suggestions we can make is that a large part of code shares a high similarity but is differencing in minor constants (this is also extractable and worth a look)
    Also we can suggest, when only type-difference are present, though for this we need to tweak the matching a bit.
    We can add some more cases here, the main thing should be the inclusion of 3-4 kinds to show the concept and possibility.
    - This concludes the modification - 
    The then written trees are then written to the files and committed as a new "<state matches here>" commit on the PR tree. All in all the maintainer should just a see that a new commit has been added which can then be reviewed.
    For this there is some knowledge of git required but it can be explained in the process.
    Alternatively we can make a mode interactively asking the user if the proposed changes are okay (similar to the chunk mode of git add), this will increase the development effort though in non-vital areas.
    
    USAGE
    The way this app is intended to be used is by explicitly stating two branches to one another which should be compared.
 */

fun main(args: Array<String>) {
    val parser = ArgParser("ignitron")
    val pullrequest by parser.option(ArgType.String, shortName = "p", description = "PR Branch").required()
    val basebranch by parser.option(ArgType.String, shortName = "b", description = "Base Branch")
    val applypatches by parser.option(ArgType.Boolean, shortName = "a", description = "Whether to apply patches automatically").default(false)
    parser.parse(args)

    val dirBuilder = FileRepositoryBuilder()
    val repository = dirBuilder.readEnvironment().findGitDir().build()
    val git = Git(repository)

    // This value is recorded so that we can set the git repository
    // Make sure to restore this once the reading is over
    val initialHead = repository.fullBranch

    // use initial head in case base branch has not been set
    val base = Branch(basebranch ?: initialHead, git)
    val pr = Branch(pullrequest, git)
    
    val diffs = base.diffsTo(pr)

    // Copy and extract all possible files that could be included in the analysis of the new path
    val newAndChangedFiles = diffs.toList().map { diffEntry ->
        diffEntry.newPath
    }.filter { filePath ->
        filePath.contains(".java") && (filePath.contains("test/java") || (filePath.contains("/test/") && !filePath.contains("resources")))
    }

    val relevantTestSource = base.relevantTestDirectories(newAndChangedFiles).distinct()
    val prMethods = pr.parseFiles(newAndChangedFiles)
    val baseMethods = base.parseDirs(relevantTestSource)


    var reports = Report(listOf(), listOf())

    for ((prDir, prBlocks) in prMethods.toList()) {
        // has to exist
        val baseBlocks = baseMethods.get(prDir)!!
        
        val prBranchSlice = BranchSlice(pr, prBlocks)
        val baseBranchMethods = BranchSlice(base, baseBlocks)

        val changedMethods = findChangedMethods(baseBranchMethods, prBranchSlice)
        val newMethods = findNewMethods(baseBranchMethods, prBranchSlice)

        println("In ${prDir}")
        println("Found ${changedMethods.size} changed methods")
        println("Found ${newMethods.size} new methods")
        println("With ${newMethods.map { elem -> elem.block_content.stream().count() }.sum() + changedMethods.map { elem -> elem.block_content.stream().count() }.sum()} nodes in total")
        println("Compare against ${baseBranchMethods.fileGroupedBlocks.flatMap { entry -> entry.value}.size}")
        
        if (newMethods.size + changedMethods.size >= 1) {
            // val type1FoundMatches = type1Matches(baseBranchMethods.fileGroupedBlocks.flatMap { entry -> entry.value }, changedMethods)
            val type2FoundNames = type2MatchesNames(baseBranchMethods.fileGroupedBlocks.flatMap { entry -> entry.value }, newMethods + changedMethods)
            // val type2FoundLiterals = type2MatchesLiterals(baseBranchMethods.fileGroupedBlocks.flatMap { entry -> entry.value }, changedMethods)
            println("Get Matches")
            val type2FoundMatches = type2MatchesNamesAndLiterals(baseBranchMethods.fileGroupedBlocks.flatMap { entry -> entry.value }, newMethods + changedMethods).toList()
            println("Get Sequences")
            val type2MaxSeq = getSequencesAndMaximize(type2FoundMatches.parallelStream())

            val methodsSharingBlocks = type2FoundNames.filter { match ->
                match.commonSubTrees.filter { node_pair ->
                    node_pair.first is BlockStmt
                }.isNotEmpty() && match.first.method_name != match.second.method_name
            }


            reports.changes += generateChanges(methodsSharingBlocks.toList(), applypatches)
            reports.warnings += generateWarnings(type2MaxSeq)
            reports.warnings += verySimilarMethods(type2FoundMatches)

        }
    }
    
    // println("Found ${prBranchSlice.fileGroupedBlocks.values.toList().flatten().size} methods total in changes")
    // println("Found ${(newMethods + changedMethods).size} methods in consideration")
    // println("Found ${baseBranchMethods.fileGroupedBlocks.values.toList().flatten().size} methods total in base")


    // println("Found ${type2FoundMatches.size} matches total")

    //     val list = methodHashMap.getOrDefault(match.first, listOf()) + match
    //     methodHashMap.put(match.first, list)
    // }
    //
    // val foundSequences = methodsSharingStatements.map {elem ->
    //     val seqs: List<Sequence> = findDirectSequences(elem)
    //     Pair(elem, seqs)
    // }.filter { elem ->
    //     elem.second.isNotEmpty()
    // }

    // println("methods matches sharing sequences : ${methodsSharingStatements.count()}")
    // println("methods matches sharing blocks : ${methodsSharingBlocks.count()}")
    // println("possible sub sequence matches detected : ${type2sequences.size}")

    // for (match in type2sequences) {
    //     for (seq in match.second) {
    //         println("=================================\n")
    //         println("Base Method ${match.first.first.method_name} ${match.first.first.occurring_file.storage.get().path}")
    //         for (node in seq.first) {
    //             println("${node.toString()}")
    //         }
    //         println("Changes Method ${match.first.second.method_name} (${match.first.second.occurring_file.storage.get().path})")
    //         for (node in seq.second) {
    //             println("${node.toString()}")
    //         }
    //     }
    // }

    // for (pair in methodsSharingBlocks) {
    //     println("==================================\n")
    //     println("Base Method (${pair.first.occurring_file.storage.get().path}):")
    //     println("${pair.first.original.toString()}")
    //     println("Changes Method (${pair.second.occurring_file.storage.get().path}):")
    //     println("${pair.second.original.toString()}")
    // }

    // val prSubTreeHashes = prBranchSlice.hashSliceTrees()
    // val baseSubTreeHashes = baseBranchSlice.hashSliceTrees()

    /*
    Here we can check:
    - Which redundancies exist in the current code
    - Which exist in the code used in the smae files before
    - Which exist in other files as seen before

    For all these we can suggest different actions
     */
    // println(prSubTreeHashes)
    // println(baseSubTreeHashes)

    // for (file in newAndChangedFiles) {
    //     println("${file}")
    // }
    // println("Following methods have experienced some changes:")
    // for (method in newMethods) {
    //     println("${method.method_name}")
    // }

    println("${Json.encodeToString(reports)}")
}

fun getMatches(baseMethods: List<MethodBlock>, changedMethods: List<MethodBlock>, transform: (MethodBlock) -> MethodBlock): Stream<HashResult> {
    return listMatches(
        changedMethods.map { block ->
            transform(block) },
        baseMethods.map { block ->
            transform(block)
        }).parallelStream().map { pair ->
            pair.first.hashCompare(pair.second)
    }
}

fun type1Matches(baseMethods: List<MethodBlock>, changedMethods: List<MethodBlock>): Stream<HashResult> {
    return getMatches(baseMethods, changedMethods) { block -> block.preprocess(CommentTransformer) }
}

fun type2MatchesNames(baseMethods: List<MethodBlock>, changedMethods: List<MethodBlock>): Stream<HashResult> {
    return getMatches(baseMethods, changedMethods) { block -> block.preprocess(CommentTransformer).preprocess(NameTransformer) }
}

fun type2MatchesLiterals(baseMethods: List<MethodBlock>, changedMethods: List<MethodBlock>): Stream<HashResult> {
    return getMatches(baseMethods, changedMethods) { block -> block.preprocess(CommentTransformer).preprocess(LiteralsTransformer) }
}

fun type2MatchesNamesAndLiterals(baseMethods: List<MethodBlock>, changedMethods: List<MethodBlock>): Stream<HashResult> {
    return getMatches(baseMethods, changedMethods) { block -> block.preprocess(CommentTransformer).preprocess(LiteralsTransformer).preprocess(NameTransformer) }
}



// fun findindirectSequence(left: List<Sequence>, right: List<Sequence>): List<List<List<Original>>> {
// }

/**
 * Find changed methods in already existing files, they may not be moved. Moved Methods are counted under new methods.
 */
fun findChangedMethods(base: BranchSlice, other: BranchSlice): List<MethodBlock> {
    // List of all trees who have changed over the diffs
    val changedFiles: List<Pair<List<MethodBlock>, List<MethodBlock>>> = other.fileGroupedBlocks.filter { entry ->
        base.fileGroupedBlocks.containsKey(entry.key)
    }.map { validEntries ->
        // We know that validEntries is part of the tree we filtered that before
        Pair(validEntries.value, base.fileGroupedBlocks.get(validEntries.key)!!)
    }

    return changedFiles.toList().flatMap { (new, old) ->
        new.filter { newMethod ->
            val equalMethods = old.toList().filter { oldMethod ->
                newMethod.method_name == oldMethod.method_name && oldMethod.compare(newMethod, TopDownCompare).classification != Classification.FullEquality
            }
            equalMethods.firstOrNull() != null
        }
    }
}


/**
 * Find new methods in existing and new files
 */
fun findNewMethods(base: BranchSlice, other: BranchSlice): List<MethodBlock> {
    // List of new Files created in the Diff
    val newFileMethods: List<MethodBlock> = other.fileGroupedBlocks.filter { entry ->
        !base.fileGroupedBlocks.containsKey(entry.key)
    }.map { entry ->
        entry.value
    }.flatten()

    val newMethod: List<MethodBlock> = other.fileGroupedBlocks.filter { entry ->
        base.fileGroupedBlocks.containsKey(entry.key)
    }.map { entry ->
        Pair(entry.value, base.fileGroupedBlocks.get(entry.key)!!)
    }.flatMap { (new, old) ->
        new.filter { newMethod ->
            old.filter { oldMethod -> oldMethod.method_name == newMethod.method_name }.firstOrNull() == null
        }
    }

    return newMethod + newFileMethods
}

fun getSequencesAndMaximize(matches: Stream<HashResult>): Map<MethodBlock, List<Pair<MethodBlock, List<Pair<Sequence, Sequence>>>>> {
    val methodsSharingStatements = matches.filter { match ->
        match.commonSubTrees.any { node_pair ->
            node_pair.first is Statement
        } && match.first.method_name != match.second.method_name
    }

    val type2sequences = methodsSharingStatements.map { elem ->
        Pair(elem, elem.directSequences())
    }.filter { elem ->
        // filter out matches without sequences common
        // a sequence is at least two statements in a row
        elem.second.isNotEmpty() && elem.first.first.method_name != elem.first.second.method_name
    }
    
    var map = HashMap<MethodBlock, List<Pair<MethodBlock, List<Pair<Sequence, Sequence>>>>>()

    for (elem in type2sequences) {
        val prv = map.getOrDefault(elem.first.first, listOf())
        map.put(elem.first.first, prv + Pair(elem.first.second, elem.second))
    }

    return getMaximumSequence(map)
}

fun checkSequenceIsSubset(left: Sequence, right: Sequence): Boolean {
    return left.toList().filter { leftNode ->
        right.any { rightNode ->
            leftNode === rightNode
        }
    }.size <= left.size
}

fun getMaximumSequence(matches: HashMap<MethodBlock, List<Pair<MethodBlock, List<Pair<Sequence, Sequence>>>>>): Map<MethodBlock, List<Pair<MethodBlock, List<Pair<Sequence, Sequence>>>>> {
     return matches.mapValues { (changeMethod, allSequences) ->
         val maxSeqMethods = allSequences.map { (otherMethod, otherSeqs: List<Pair<Sequence, Sequence>>) ->
            val maxSeqs = otherSeqs.filter { certainSequence ->
                otherSeqs.filter { checkSeq ->
                    checkSequenceIsSubset(certainSequence.first, checkSeq.first)
                }.size == 1
            }
            Pair(otherMethod, maxSeqs)
        }
         maxSeqMethods
    }
}

fun generateLocation(block: MethodBlock, location: Pair<Position, Position>): Location {
    return Location(
        file = block.occurring_file.storage.get().path.toString(),
        start = Line(
            line = location.first.line,
            column = location.first.column
        ),
        end = Line(
            line = location.second.line,
            column = location.second.column
        )
    )
}

fun verySimilarMethods(hashResults: List<HashResult>): List<Warning> {
    return hashResults.filter { result ->
        val leftSize = result.first.block_content.stream().count()
        val matchedSize = result.commonSubTrees.map { elem ->
            elem.first
        }.distinct().map { elem ->
            elem.stream().count()
        }.sum()
        // if over 90 % matched nodes, the similarity is too high to be well maintainable
        // actively exclude empty block from occuring on the right side, they are too misleading
        matchedSize.toFloat() / leftSize.toFloat() >= 0.75 && !(leftSize == 1L && result.second.block_content.stream().count() > 1)
    }.filter { elem ->
        // Ensure it is not the same method
       elem.first.method_name != elem.second.method_name
    }.map { result ->
        Warning(
            location = listOf(
                generateLocation(result.first, Pair(result.first.block_content.tokenRange.get().toRange().get().begin, result.first.block_content.tokenRange.get().toRange().get().end)),
                generateLocation(result.second, Pair(result.second.block_content.tokenRange.get().toRange().get().begin, result.second.block_content.tokenRange.get().toRange().get().end))
            ),
            reason = "High Method Similarity",
            changes_content = result.first.original.toString(),
            base_content = result.second.original.toString()
        )
    }
}

fun generateChanges(hasSimilarBlocks: List<HashResult>, applypatches: Boolean): List<Change> {
    var changes = listOf<Change>()
    for (result in hasSimilarBlocks) {
        if (result.commonSubTrees.get(0).first === (result.first.original as MethodDeclaration).body.get() &&
            result.commonSubTrees.get(0).second === (result.second.original as MethodDeclaration).body.get()) {
            // Compare the annotations, for now we just take if they are a simple test we can remove one of them
            // Note: This will lead to false postives to false positives, as they do negative tests to see if their test suite panics with certain names on empty methods
            val leftAnnotations = result.first.annotations.map { annotation ->
                annotation.nameAsString
            }
            val rightAnnotations = result.second.annotations.map { annotation ->
                annotation.nameAsString
            }

            // Total match, can be removed
            if (leftAnnotations == rightAnnotations) {
                changes += Change(
                    location = listOf(
                        generateLocation(result.first, Pair(result.first.original.tokenRange.get().toRange().get().begin, result.first.original.tokenRange.get().toRange().get().end)),
                        generateLocation(result.second, Pair(result.second.original.tokenRange.get().toRange().get().begin, result.second.original.tokenRange.get().toRange().get().end))
                    ),
                    action = "Remove Duplicate Block",
                    changes = result.first.original.toString()
                )
                // this might fail, further treatment could be done
                result.first.original.remove()
                if (applypatches) {
                    // if desired save the modified state
                    result.first.occurring_file.storage.get().save()
                }
            }
        }
    }
    
    return changes
}

fun generateWarnings(map: Map<MethodBlock, List<Pair<MethodBlock, List<Pair<Sequence, Sequence>>>>>): List<Warning> {
    return map.flatMap { (changeMethod, allMatches) ->
        allMatches.flatMap { (otherMethod, allSequences) ->
            allSequences.map { (change, base) ->
                val changeRange = Pair(change.first().tokenRange.get().toRange().get().begin, change.last().tokenRange.get().toRange().get().end)
                val baseRange = Pair(base.first().tokenRange.get().toRange().get().begin, base.last().tokenRange.get().toRange().get().end)
                Warning(
                    location = listOf(
                        generateLocation(changeMethod, changeRange),
                        generateLocation(otherMethod, baseRange)
                    ),
                    reason = "Similar Sequence",
                    changes_content = change.fold(String(), { acc, elem ->
                        acc + elem.toString() + "\n"
                    }),
                    base_content = base.fold(String(), {acc, elem -> 
                        acc + elem.toString() + "\n"
                    })
                )
            }
        }
    }
}
